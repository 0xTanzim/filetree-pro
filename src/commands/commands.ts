import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';

export function convertTextToTree(text: string): string {
  const lines = text.split('\n').filter(line => line.trim());
  const treeLines: string[] = [];

  treeLines.push('# File Tree from Text');
  treeLines.push('');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // Determine if it's a file or folder based on extension or trailing slash
    const isFolder = line.endsWith('/') || line.endsWith('\\') || !line.includes('.');
    const icon = isFolder ? '📁' : '📄';

    // Create tree structure with proper indentation
    const indent = '  '.repeat(Math.min(i, 3)); // Limit depth for readability
    const prefix = i === lines.length - 1 ? '└── ' : '├── ';

    treeLines.push(`${indent}${prefix}${icon} ${line}`);
  }

  treeLines.push('');
  treeLines.push('*Generated by FileTree Pro Extension*');

  return treeLines.join('\n');
}

export function registerCommands(): vscode.Disposable[] {
  const disposables: vscode.Disposable[] = [];

  // Generate File Tree command (main command)
  disposables.push(
    vscode.commands.registerCommand('filetree-pro.generateFileTree', async (uri: vscode.Uri) => {
      try {
        if (!uri) {
          vscode.window.showErrorMessage('Please right-click on a folder to generate file tree');
          return;
        }

        // Get the folder path
        const folderPath = uri.fsPath;
        const folderName = path.basename(folderPath);

        // Ask user for format preference
        const formatChoice = await vscode.window.showQuickPick(
          [
            { label: '📄 Markdown', value: 'markdown' },
            { label: '📊 JSON', value: 'json' },
            { label: '🎨 SVG', value: 'svg' },
            { label: '📝 ASCII', value: 'ascii' },
          ],
          {
            placeHolder: 'Choose output format',
            canPickMany: false,
          }
        );

        if (!formatChoice) {
          return; // User cancelled
        }

        // Ask user for icon preference
        const iconChoice = await vscode.window.showQuickPick(['With Icons', 'Without Icons'], {
          placeHolder: 'Choose tree style',
          canPickMany: false,
        });

        if (!iconChoice) {
          return; // User cancelled
        }

        const useIcons = iconChoice === 'With Icons';

        // Show progress with loading indicator
        const progressOptions = {
          location: vscode.ProgressLocation.Notification,
          title: `Generating file tree for ${folderName}`,
          cancellable: false,
        };

        await vscode.window.withProgress(progressOptions, async progress => {
          progress.report({ message: 'Starting tree generation...' });

          // Generate the file tree based on format with progress updates
          const treeContent = await generateFileTree(
            folderPath,
            10,
            useIcons,
            formatChoice.value,
            message => {
              progress.report({ message });
            }
          );

          progress.report({ message: 'Creating document...' });

          // Create an untitled document with the tree content
          const document = await vscode.workspace.openTextDocument({
            content: treeContent,
            language:
              formatChoice.value === 'json'
                ? 'json'
                : formatChoice.value === 'svg'
                  ? 'xml'
                  : formatChoice.value === 'ascii'
                    ? 'plaintext'
                    : 'markdown',
          });

          // Show the document in a new tab (unsaved mode)
          await vscode.window.showTextDocument(document);

          vscode.window.showInformationMessage(
            `File tree generated successfully! Ready to save when you're ready.`
          );
        });
      } catch (error) {
        vscode.window.showErrorMessage(`Failed to generate file tree: ${error}`);
      }
    })
  );

  // Convert Text to Tree command (new feature)
  disposables.push(
    vscode.commands.registerCommand('filetree-pro.convertTextToTree', async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor found');
        return;
      }

      const selection = editor.selection;
      const text = editor.document.getText(selection);

      if (!text.trim()) {
        vscode.window.showErrorMessage('Please select some text to convert to tree format');
        return;
      }

      try {
        const treeText = convertTextToTree(text);

        // Create a new document with the tree
        const document = await vscode.workspace.openTextDocument({
          content: treeText,
          language: 'markdown',
        });

        await vscode.window.showTextDocument(document);

        vscode.window.showInformationMessage('Text converted to tree format!');
      } catch (error) {
        vscode.window.showErrorMessage(`Error converting text to tree: ${error}`);
      }
    })
  );

  return disposables;
}

async function generateFileTree(
  rootPath: string,
  maxDepth: number = 10,
  forceShowIcons?: boolean,
  format: string = 'markdown',
  progressCallback?: (message: string) => void
): Promise<string> {
  const lines: string[] = [];

  // Get user settings or use forced value
  const config = vscode.workspace.getConfiguration('filetree-pro');
  const showIcons =
    forceShowIcons !== undefined ? forceShowIcons : config.get<boolean>('showIcons', true);

  // Generate based on format
  switch (format) {
    case 'json':
      return await generateJsonTree(rootPath, maxDepth, showIcons, progressCallback);
    case 'svg':
      return await generateSvgTree(rootPath, maxDepth, showIcons, progressCallback);
    case 'ascii':
      return await generateAsciiTree(rootPath, maxDepth, showIcons, progressCallback);
    case 'markdown':
    default:
      return await generateMarkdownTree(rootPath, maxDepth, showIcons, progressCallback);
  }
}

export async function generateTreeLines(
  currentPath: string,
  prefix: string,
  lines: string[],
  depth: number,
  maxDepth: number,
  showIcons: boolean,
  rootPath: string,
  progressCallback?: (message: string) => void
): Promise<void> {
  if (depth > maxDepth) {
    return;
  }

  try {
    // Update progress for large directories
    if (progressCallback && depth === 0) {
      progressCallback(`Reading directory: ${path.basename(currentPath)}`);
    }

    const items = await vscode.workspace.fs.readDirectory(vscode.Uri.file(currentPath));

    // Sort items: folders first, then files
    const folders: string[] = [];
    const files: string[] = [];

    // Process items in batches to avoid memory issues
    const batchSize = 100;
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);

      // Process batch asynchronously
      const batchPromises = batch.map(async ([item, fileType]) => {
        const itemPath = path.join(currentPath, item);
        const isExcluded = shouldExclude(item, itemPath, rootPath);

        if (fileType === vscode.FileType.Directory) {
          return { item, type: 'folder' as const, isExcluded };
        } else {
          return { item, type: 'file' as const, isExcluded };
        }
      });

      const batchResults = await Promise.all(batchPromises);

      for (const result of batchResults) {
        if (result) {
          if (result.type === 'folder') {
            folders.push(result.item);
          } else {
            files.push(result.item);
          }
        }
      }

      // Update progress for large directories
      if (progressCallback && items.length > batchSize) {
        const progress = Math.min(100, Math.round(((i + batchSize) / items.length) * 100));
        progressCallback(`Processing items: ${progress}%`);
      }

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Sort alphabetically
    folders.sort();
    files.sort();

    // Process folders with memory management
    for (let i = 0; i < folders.length; i++) {
      const folder = folders[i];
      const isLast = i === folders.length - 1 && files.length === 0;
      const connector = isLast ? '└── ' : '├── ';
      const newPrefix = prefix + (isLast ? '    ' : '│   ');

      // Check if folder is excluded
      const folderPath = path.join(currentPath, folder);
      const isExcluded = shouldExclude(folder, folderPath, rootPath);
      const exclusionIndicator = isExcluded ? ' 🚫 (auto-hidden)' : '';

      lines.push(`${prefix}${connector}${showIcons ? '📁 ' : ''}${folder}/${exclusionIndicator}`);

      if (!isExcluded) {
        const folderPath = path.join(currentPath, folder);
        await generateTreeLines(
          folderPath,
          newPrefix,
          lines,
          depth + 1,
          maxDepth,
          showIcons,
          rootPath,
          progressCallback
        );
      }

      // Yield control periodically to prevent blocking
      if (i % 10 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Process files with memory management
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const isLast = i === files.length - 1;
      const connector = isLast ? '└── ' : '├── ';

      // Check if file is excluded
      const filePath = path.join(currentPath, file);
      const isExcluded = shouldExclude(file, filePath, rootPath);
      const exclusionIndicator = isExcluded ? ' 🚫 (auto-hidden)' : '';

      // Get file icon based on extension
      const icon = showIcons ? getFileIcon(file) + ' ' : '';
      lines.push(`${prefix}${connector}${icon}${file}${exclusionIndicator}`);

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  } catch (error) {
    lines.push(`${prefix}└── ❌ Error reading directory: ${error}`);
  }
}

function getFileIcon(filename: string): string {
  const ext = path.extname(filename).toLowerCase();
  const basename = path.basename(filename).toLowerCase();

  const iconMap: { [key: string]: string } = {
    // JavaScript/TypeScript Ecosystem
    '.js': '📄',
    '.ts': '📄',
    '.jsx': '📄',
    '.tsx': '📄',
    '.json': '📄',
    '.mjs': '📄',
    '.cjs': '📄',

    // Web Technologies
    '.html': '🌐',
    '.htm': '🌐',
    '.css': '🎨',
    '.scss': '🎨',
    '.sass': '🎨',
    '.less': '🎨',
    '.styl': '🎨',
    '.vue': '🟢',
    '.svelte': '🟠',

    // Python Ecosystem
    '.py': '🐍',
    '.pyw': '🐍',
    '.pyi': '🐍',
    '.ipynb': '📓',

    // Java Ecosystem
    '.java': '☕',
    '.class': '☕',
    '.jar': '☕',
    '.war': '☕',

    // C/C++ Ecosystem
    '.cpp': '⚙️',
    '.cc': '⚙️',
    '.cxx': '⚙️',
    '.c': '⚙️',
    '.h': '⚙️',
    '.hpp': '⚙️',
    '.hxx': '⚙️',
    '.obj': '⚙️',
    '.o': '⚙️',
    '.so': '⚙️',
    '.dll': '⚙️',
    '.exe': '⚙️',

    // Go
    '.go': '🐹',
    '.mod': '🐹',
    '.sum': '🐹',

    // Rust
    '.rs': '🦀',

    // PHP
    '.php': '🐘',
    '.phtml': '🐘',

    // Ruby
    '.rb': '💎',
    '.erb': '💎',
    '.rake': '💎',
    '.gemspec': '💎',

    // Swift
    '.swift': '🍎',

    // Kotlin
    '.kt': '🟦',
    '.kts': '🟦',

    // Scala
    '.scala': '🔴',
    '.sc': '🔴',

    // C#
    '.cs': '🟣',
    '.csproj': '🟣',
    '.sln': '🟣',

    // F#
    '.fs': '🟣',
    '.fsx': '🟣',
    '.fsproj': '🟣',

    // Dart
    '.dart': '🔵',

    // R
    '.r': '📊',
    '.R': '📊',
    '.Rmd': '📊',

    // MATLAB
    '.m': '📊',
    '.mat': '📊',

    // Julia
    '.jl': '🟣',

    // Perl
    '.pl': '🐪',
    '.pm': '🐪',
    '.t': '🐪',

    // Lua
    '.lua': '🔵',

    // Haskell
    '.hs': '🟣',
    '.lhs': '🟣',

    // Clojure
    '.clj': '🟢',
    '.cljs': '🟢',
    '.edn': '🟢',

    // Elixir
    '.ex': '🟣',
    '.exs': '🟣',
    '.eex': '🟣',

    // Erlang
    '.erl': '🔴',

    // OCaml
    '.ml': '🟠',
    '.mli': '🟠',

    // Nim
    '.nim': '🟡',

    // Zig
    '.zig': '🟡',

    // V
    '.v': '🔵',

    // Assembly
    '.asm': '⚙️',
    '.s': '⚙️',
    '.S': '⚙️',

    // Shell Scripts
    '.sh': '🐚',
    '.bash': '🐚',
    '.zsh': '🐚',
    '.fish': '🐚',
    '.bat': '🐚',
    '.cmd': '🐚',
    '.ps1': '🐚',

    // Configuration Files
    '.yml': '⚙️',
    '.yaml': '⚙️',
    '.xml': '📄',
    '.toml': '⚙️',
    '.ini': '⚙️',
    '.cfg': '⚙️',
    '.conf': '⚙️',

    // Documentation
    '.md': '📝',
    '.mdx': '📝',
    '.rst': '📝',
    '.txt': '📄',
    '.adoc': '📝',

    // Images
    '.svg': '🖼️',
    '.png': '🖼️',
    '.jpg': '🖼️',
    '.jpeg': '🖼️',
    '.gif': '🖼️',
    '.ico': '🖼️',
    '.bmp': '🖼️',
    '.tiff': '🖼️',
    '.webp': '🖼️',

    // Documents
    '.pdf': '📕',
    '.doc': '📄',
    '.docx': '📄',
    '.xls': '📊',
    '.xlsx': '📊',
    '.ppt': '📊',
    '.pptx': '📊',

    // Archives
    '.zip': '📦',
    '.tar': '📦',
    '.gz': '📦',
    '.bz2': '📦',
    '.rar': '📦',
    '.7z': '📦',

    // Database
    '.sql': '🗄️',
    '.db': '🗄️',
    '.sqlite': '🗄️',

    // GraphQL
    '.graphql': '🟣',
    '.gql': '🟣',

    // Docker
    dockerfile: '🐳',

    // Makefiles
    makefile: '⚙️',

    // Special Files
    '.gitignore': '🚫',
    '.env': '🔒',
    '.lock': '🔒',
    '.log': '📋',
    '.tmp': '🗑️',
    '.cache': '🗑️',
    '.bak': '🗑️',
    '.old': '🗑️',
  };

  // Check for special filenames (case-insensitive)
  if (basename === 'dockerfile') return '🐳';
  if (basename === 'makefile') return '⚙️';
  if (basename === 'readme' || basename.startsWith('readme.')) return '📖';
  if (basename === 'license' || basename.startsWith('license.')) return '📜';
  if (basename === 'changelog' || basename.startsWith('changelog.')) return '📝';
  if (basename === '.gitignore') return '🚫';
  if (basename === '.env') return '🔒';

  return iconMap[ext] || '📄';
}

export async function readGitignore(rootPath: string): Promise<string[]> {
  const gitignorePath = path.join(rootPath, '.gitignore');
  try {
    const content = await vscode.workspace.fs.readFile(vscode.Uri.file(gitignorePath));
    return content
      .toString()
      .split('\n')
      .filter(line => line.trim() && !line.startsWith('#'))
      .map(line => line.trim());
  } catch {
    return [];
  }
}

/**
 * Converts a glob pattern to a RegExp for file path matching.
 *
 * Supports common glob patterns:
 * - '*' matches any characters except path separators (e.g., "*.js" matches "file.js")
 * - '**' matches any path segments including separators (e.g., double-star patterns)
 * - '?' matches any single character
 *
 * @param pattern - The glob pattern to convert (e.g., "*.log", "temp?")
 * @returns A RegExp object that can be used to test file paths
 *
 * @example
 * ```typescript
 * const regex = globToRegex("*.log");
 * regex.test("error.log"); // true
 * regex.test("app.js"); // false
 * ```
 */
function globToRegex(pattern: string): RegExp {
  // Handle directory patterns ending with /
  if (pattern.endsWith('/')) {
    // Remove trailing slash and treat as exact directory name match
    const dirName = pattern.slice(0, -1);
    const escapedDirName = dirName.replace(/[.+^${}()|[\]\\]/g, '\\$&');
    return new RegExp(`(^|/)${escapedDirName}(/|$)`, 'i');
  }

  // Escape special regex characters except for our glob patterns
  let regexPattern = pattern
    .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
    .replace(/\\\*/g, '__STAR__') // Temporarily replace escaped asterisks
    .replace(/\*\*/g, '.*') // ** means match any path segment(s)
    .replace(/__STAR__/g, '[^/]*') // * means match any characters except path separator
    .replace(/\\\?/g, '.'); // ? means match any single character

  // For exact directory/file matches, anchor the pattern
  if (!pattern.includes('*') && !pattern.includes('/')) {
    // Exact name match - should only match at path boundaries
    regexPattern = `(^|/)${regexPattern}(/|$)`;
  } else if (pattern.includes('**/')) {
    // Double star patterns - ensure proper path matching
    regexPattern = `(^|/)${regexPattern}(/|$)`;
  } else if (pattern.startsWith('*.')) {
    // File extension patterns - anchor to end of string
    regexPattern = `${regexPattern}$`;
  }

  return new RegExp(regexPattern, 'i');
}

export function shouldExclude(item: string, fullPath?: string, rootPath?: string): boolean {
  // Get user-defined exclusions from settings
  const config = vscode.workspace.getConfiguration('filetree-pro');
  const userExclusions = config.get<string[]>('exclude', []);
  const respectGitignore = config.get<boolean>('respectGitignore', true);

  // Read .gitignore patterns if enabled (synchronously for now)
  let gitignorePatterns: string[] = [];
  if (respectGitignore && rootPath) {
    try {
      const gitignorePath = path.join(rootPath, '.gitignore');
      if (fs.existsSync(gitignorePath)) {
        const content = fs.readFileSync(gitignorePath, 'utf8');
        gitignorePatterns = content
          .split('\n')
          .filter((line: string) => line.trim() && !line.startsWith('#'))
          .map((line: string) => line.trim());
      }
    } catch (error) {
      // Ignore errors and continue without gitignore
    }
  }

  // Common folders and files to exclude
  const defaultExcludePatterns = [
    // Build and dependency folders
    'node_modules',
    'dist',
    'build',
    'out',
    'target',
    'bin',
    'obj',
    '.next',
    '.nuxt',
    '.output',
    'coverage',
    'coverage.lcov',
    '.nyc_output',
    'bower_components',
    'jspm_packages',

    // Version control
    '.git',
    '.svn',
    '.hg',
    '.bzr',

    // IDE and editor folders
    '.vscode',
    '.idea',
    '.vs',
    '.cursor',
    '.atom',
    '.sublime-project',
    '.sublime-workspace',

    // Environment files (sensitive)
    '.env.local',
    '.env.production',
    '.env.development',
    '.env.test',
    'venv',
    '.venv',
    'env',
    '.python-version',
    '.ruby-version',
    '.node-version',

    // OS generated
    '.DS_Store',
    'Thumbs.db',
    '.Trash',
    'desktop.ini',
    '$RECYCLE.BIN',

    // Logs and temp files
    '*.log',
    '*.tmp',
    '*.cache',
    '*.pyc',
    '__pycache__',
    '*.swp',
    '*.swo',
    '*~',

    // Package manager lock files (often needed for debugging/reproducible builds)
    // Note: These are sometimes committed and needed, so being more selective
    'composer.lock',
    'Gemfile.lock',
    'Pipfile.lock',
    'mix.lock',

    // Build artifacts
    '*.min.js',
    '*.min.css',
    '*.map',
    '*.bundle.js',
    '*.chunk.js',

    // Generated/config files (commonly auto-generated but sometimes important)
    '.eslintcache',
    '.babelrc',
    '.babelrc.js',
    'tsconfig.build.json',
    'karma.conf.js',
  ];

  // Combine default, user, and gitignore exclusions
  const excludePatterns = [...defaultExcludePatterns, ...userExclusions, ...gitignorePatterns];

  const itemLower = item.toLowerCase();

  // For user patterns with glob syntax (like **/node_modules/**), we need the full path
  const pathToCheck = fullPath || item;

  // Normalize path separators for cross-platform compatibility
  const normalizedPath = pathToCheck.replace(/\\/g, '/');

  // Check exact matches (case-insensitive) - for simple patterns
  if (
    excludePatterns.some(pattern => {
      // Skip glob patterns for exact match check
      if (pattern.includes('*') || pattern.includes('/')) {
        return false;
      }
      // For exact name matching, only match complete names, not substrings
      return pattern.toLowerCase() === itemLower;
    })
  ) {
    return true;
  }

  // Check wildcard and glob patterns
  for (const pattern of excludePatterns) {
    if (pattern.includes('*') || pattern.includes('/')) {
      try {
        // Handle file extension patterns like *.log, *.tmp first (simple case)
        if (pattern.startsWith('*.') && !pattern.includes('/')) {
          const extension = pattern.substring(1); // Remove the * to get .log, .tmp, etc.
          if (item.toLowerCase().endsWith(extension.toLowerCase())) {
            return true;
          }
        } else {
          // Handle complex glob patterns like **/node_modules/**, **/*.log, etc.
          const regex = globToRegex(pattern);
          if (regex.test(normalizedPath) || regex.test(item)) {
            return true;
          }
        }
      } catch (error) {
        // If there's an error with the pattern, log it and continue
        console.warn(`Invalid exclusion pattern: ${pattern}`, error);
        continue;
      }
    }
  }

  // Check for common build/artifact patterns (only exact matches)
  if (
    itemLower === 'build' ||
    itemLower === 'dist' ||
    itemLower === 'cache' ||
    itemLower === 'temp' ||
    itemLower === 'tmp'
  ) {
    return true;
  }

  return false;
}

export async function generateMarkdownTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const lines: string[] = [];

  // Add header
  lines.push(`# File Tree: ${path.basename(rootPath)}`);
  lines.push('');
  lines.push(`Generated on: ${new Date().toLocaleString()}`);
  lines.push(`Root path: \`${rootPath}\``);
  lines.push('');
  lines.push('```');

  // Generate tree structure
  await generateTreeLines(rootPath, '', lines, 0, maxDepth, showIcons, rootPath, progressCallback);

  lines.push('```');
  lines.push('');
  lines.push('---');
  lines.push('*Generated by FileTree Pro Extension*');

  return lines.join('\n');
}

export async function generateJsonTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const treeData = await buildTreeData(
    rootPath,
    maxDepth,
    showIcons,
    rootPath,
    0,
    progressCallback
  );

  const jsonOutput = {
    name: path.basename(rootPath),
    path: rootPath,
    type: 'directory',
    children: treeData,
    generated: new Date().toISOString(),
    generator: 'FileTree Pro Extension',
    note: 'Common build folders, dependencies, and temporary files are automatically excluded.',
    showIcons: showIcons,
  };

  return JSON.stringify(jsonOutput, null, 2);
}

export async function generateSvgTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const treeData = await buildTreeData(
    rootPath,
    maxDepth,
    showIcons,
    rootPath,
    0,
    progressCallback
  );

  // Calculate dimensions based on content
  const nodeCount = countNodes(treeData);
  const svgWidth = 1000;
  const svgHeight = Math.max(800, nodeCount * 25 + 100);

  let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">
  <defs>
      <style>
      .title { font-family: 'Arial', sans-serif; font-size: 18px; font-weight: bold; fill: #2c3e50; }
      .subtitle { font-family: 'Arial', sans-serif; font-size: 12px; fill: #7f8c8d; }
      .folder-text { font-family: 'Consolas', 'Courier New', monospace; font-size: 14px; fill: #27ae60; font-weight: bold; }
      .file-text { font-family: 'Consolas', 'Courier New', monospace; font-size: 14px; fill: #3498db; }
      .icon { font-family: 'Arial', sans-serif; font-size: 16px; }
      .line { stroke: #bdc3c7; stroke-width: 1.5; }
      .background { fill: #f8f9fa; }
      .header-bg { fill: #ecf0f1; }
      </style>
  </defs>

  <!-- Background -->
  <rect width="${svgWidth}" height="${svgHeight}" class="background"/>

  <!-- Header -->
  <rect x="0" y="0" width="${svgWidth}" height="60" class="header-bg"/>
  <text x="20" y="25" class="title">📁 File Tree: ${path.basename(rootPath)}</text>
          <text x="20" y="45" class="subtitle">Generated: ${new Date().toLocaleString()} | FileTree Pro Extension</text>

  <!-- Tree Structure -->`;

  let yOffset = 80;
  const renderNode = (node: any, x: number, level: number, isLast: boolean = false) => {
    const icon = showIcons ? (node.type === 'directory' ? '📁' : getFileIcon(node.name)) : '';
    const displayName = node.name + (node.type === 'directory' ? '/' : '');
    const textClass = node.type === 'directory' ? 'folder-text' : 'file-text';

    // Draw connecting line if not root
    if (level > 0) {
      svgContent += `
    <line x1="${x - 15}" y1="${yOffset - 10}" x2="${x - 15}" y2="${yOffset}" class="line"/>`;
    }

    // Draw horizontal line
    svgContent += `
    <line x1="${x - 15}" y1="${yOffset}" x2="${x - 5}" y2="${yOffset}" class="line"/>`;

    // Draw icon and text
    if (showIcons && icon) {
      svgContent += `
    <text x="${x}" y="${yOffset + 5}" class="icon">${icon}</text>
    <text x="${x + 25}" y="${yOffset + 5}" class="${textClass}">${displayName}</text>`;
    } else {
      svgContent += `
    <text x="${x}" y="${yOffset + 5}" class="${textClass}">${displayName}</text>`;
    }

    if (node.children && node.children.length > 0) {
      yOffset += 30;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const isLastChild = i === node.children.length - 1;
        renderNode(child, x + 30, level + 1, isLastChild);
        yOffset += 25;
      }
    }
    yOffset += 10;
  };

  for (const node of treeData) {
    renderNode(node, 30, 0);
  }

  svgContent += `
</svg>`;

  return svgContent;
}

export async function generateAsciiTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const lines: string[] = [];

  // Add header
  lines.push(`File Tree: ${path.basename(rootPath)}`);
  lines.push(`Generated on: ${new Date().toLocaleString()}`);
  lines.push(`Root path: ${rootPath}`);
  lines.push('');
  lines.push('─'.repeat(80));

  // Generate tree structure
  await generateTreeLines(rootPath, '', lines, 0, maxDepth, showIcons, rootPath, progressCallback);

  lines.push('');
  lines.push('─'.repeat(80));
  lines.push('Generated by FileTree Pro Extension');

  return lines.join('\n');
}

function countNodes(nodes: any[]): number {
  let count = nodes.length;
  for (const node of nodes) {
    if (node.children && node.children.length > 0) {
      count += countNodes(node.children);
    }
  }
  return count;
}

export async function buildTreeData(
  currentPath: string,
  maxDepth: number,
  showIcons: boolean,
  rootPath: string,
  depth: number = 0,
  progressCallback?: (message: string) => void
): Promise<any[]> {
  if (depth > maxDepth) {
    return [];
  }

  try {
    // Update progress for large directories
    if (progressCallback && depth === 0) {
      progressCallback(`Building tree data: ${path.basename(currentPath)}`);
    }

    const items = await vscode.workspace.fs.readDirectory(vscode.Uri.file(currentPath));
    const result: any[] = [];

    // Sort items: folders first, then files
    const folders: string[] = [];
    const files: string[] = [];

    // Process items in batches to avoid memory issues
    const batchSize = 100;
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);

      // Process batch asynchronously
      const batchPromises = batch.map(async ([item, fileType]) => {
        const itemPath = path.join(currentPath, item);
        const isExcluded = shouldExclude(item, itemPath, rootPath);

        if (fileType === vscode.FileType.Directory) {
          return { item, type: 'folder' as const, isExcluded };
        } else {
          return { item, type: 'file' as const, isExcluded };
        }
      });

      const batchResults = await Promise.all(batchPromises);

      for (const batchResult of batchResults) {
        if (batchResult && !batchResult.isExcluded) {
          if (batchResult.type === 'folder') {
            folders.push(batchResult.item);
          } else {
            files.push(batchResult.item);
          }
        }
      }

      // Update progress for large directories
      if (progressCallback && items.length > batchSize) {
        const progress = Math.min(100, Math.round(((i + batchSize) / items.length) * 100));
        progressCallback(`Processing items: ${progress}%`);
      }

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Sort alphabetically
    folders.sort();
    files.sort();

    // Process folders with memory management
    for (let i = 0; i < folders.length; i++) {
      const folder = folders[i];
      const folderPath = path.join(currentPath, folder);
      const children = await buildTreeData(
        folderPath,
        maxDepth,
        showIcons,
        rootPath,
        depth + 1,
        progressCallback
      );

      result.push({
        name: folder,
        type: 'directory',
        path: folderPath,
        children: children,
        icon: showIcons ? '📁' : null,
      });

      // Yield control periodically to prevent blocking
      if (i % 10 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Process files with memory management
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      result.push({
        name: file,
        type: 'file',
        path: path.join(currentPath, file),
        icon: showIcons ? getFileIcon(file) : null,
      });

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    return result;
  } catch (error) {
    return [
      {
        name: 'Error reading directory',
        type: 'error',
        error: String(error),
      },
    ];
  }
}

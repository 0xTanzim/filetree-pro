import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';

export function convertTextToTree(text: string): string {
  const lines = text.split('\n').filter(line => line.trim());
  const treeLines: string[] = [];

  treeLines.push('# File Tree from Text');
  treeLines.push('');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // Determine if it's a file or folder based on extension or trailing slash
    const isFolder = line.endsWith('/') || line.endsWith('\\') || !line.includes('.');
    const icon = isFolder ? 'ğŸ“' : 'ğŸ“„';

    // Create tree structure with proper indentation
    const indent = '  '.repeat(Math.min(i, 3)); // Limit depth for readability
    const prefix = i === lines.length - 1 ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';

    treeLines.push(`${indent}${prefix}${icon} ${line}`);
  }

  treeLines.push('');
  treeLines.push('*Generated by FileTree Pro Extension*');

  return treeLines.join('\n');
}

export function registerCommands(): vscode.Disposable[] {
  const disposables: vscode.Disposable[] = [];

  // Generate File Tree command (main command)
  disposables.push(
    vscode.commands.registerCommand('filetree-pro.generateFileTree', async (uri: vscode.Uri) => {
      try {
        if (!uri) {
          vscode.window.showErrorMessage('Please right-click on a folder to generate file tree');
          return;
        }

        // Get the folder path
        const folderPath = uri.fsPath;
        const folderName = path.basename(folderPath);

        // Ask user for format preference
        const formatChoice = await vscode.window.showQuickPick(
          [
            { label: 'ğŸ“„ Markdown', value: 'markdown' },
            { label: 'ğŸ“Š JSON', value: 'json' },
            { label: 'ğŸ¨ SVG', value: 'svg' },
            { label: 'ğŸ“ ASCII', value: 'ascii' },
          ],
          {
            placeHolder: 'Choose output format',
            canPickMany: false,
          }
        );

        if (!formatChoice) {
          return; // User cancelled
        }

        // Ask user for icon preference
        const iconChoice = await vscode.window.showQuickPick(['With Icons', 'Without Icons'], {
          placeHolder: 'Choose tree style',
          canPickMany: false,
        });

        if (!iconChoice) {
          return; // User cancelled
        }

        const useIcons = iconChoice === 'With Icons';

        // Show progress with loading indicator
        const progressOptions = {
          location: vscode.ProgressLocation.Notification,
          title: `Generating file tree for ${folderName}`,
          cancellable: false,
        };

        await vscode.window.withProgress(progressOptions, async progress => {
          progress.report({ message: 'Starting tree generation...' });

          // Generate the file tree based on format with progress updates
          const treeContent = await generateFileTree(
            folderPath,
            10,
            useIcons,
            formatChoice.value,
            message => {
              progress.report({ message });
            }
          );

          progress.report({ message: 'Creating document...' });

          // Create an untitled document with the tree content
          const document = await vscode.workspace.openTextDocument({
            content: treeContent,
            language:
              formatChoice.value === 'json'
                ? 'json'
                : formatChoice.value === 'svg'
                  ? 'xml'
                  : formatChoice.value === 'ascii'
                    ? 'plaintext'
                    : 'markdown',
          });

          // Show the document in a new tab (unsaved mode)
          await vscode.window.showTextDocument(document);

          vscode.window.showInformationMessage(
            `File tree generated successfully! Ready to save when you're ready.`
          );
        });
      } catch (error) {
        vscode.window.showErrorMessage(`Failed to generate file tree: ${error}`);
      }
    })
  );

  // Convert Text to Tree command (new feature)
  disposables.push(
    vscode.commands.registerCommand('filetree-pro.convertTextToTree', async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor found');
        return;
      }

      const selection = editor.selection;
      const text = editor.document.getText(selection);

      if (!text.trim()) {
        vscode.window.showErrorMessage('Please select some text to convert to tree format');
        return;
      }

      try {
        const treeText = convertTextToTree(text);

        // Create a new document with the tree
        const document = await vscode.workspace.openTextDocument({
          content: treeText,
          language: 'markdown',
        });

        await vscode.window.showTextDocument(document);

        vscode.window.showInformationMessage('Text converted to tree format!');
      } catch (error) {
        vscode.window.showErrorMessage(`Error converting text to tree: ${error}`);
      }
    })
  );

  return disposables;
}

async function generateFileTree(
  rootPath: string,
  maxDepth: number = 10,
  forceShowIcons?: boolean,
  format: string = 'markdown',
  progressCallback?: (message: string) => void
): Promise<string> {
  const lines: string[] = [];

  // Get user settings or use forced value
  const config = vscode.workspace.getConfiguration('filetree-pro');
  const showIcons =
    forceShowIcons !== undefined ? forceShowIcons : config.get<boolean>('showIcons', true);

  // Generate based on format
  switch (format) {
    case 'json':
      return await generateJsonTree(rootPath, maxDepth, showIcons, progressCallback);
    case 'svg':
      return await generateSvgTree(rootPath, maxDepth, showIcons, progressCallback);
    case 'ascii':
      return await generateAsciiTree(rootPath, maxDepth, showIcons, progressCallback);
    case 'markdown':
    default:
      return await generateMarkdownTree(rootPath, maxDepth, showIcons, progressCallback);
  }
}

export async function generateTreeLines(
  currentPath: string,
  prefix: string,
  lines: string[],
  depth: number,
  maxDepth: number,
  showIcons: boolean,
  rootPath: string,
  progressCallback?: (message: string) => void
): Promise<void> {
  if (depth > maxDepth) {
    return;
  }

  try {
    // Update progress for large directories
    if (progressCallback && depth === 0) {
      progressCallback(`Reading directory: ${path.basename(currentPath)}`);
    }

    const items = await vscode.workspace.fs.readDirectory(vscode.Uri.file(currentPath));

    // Sort items: folders first, then files
    const folders: string[] = [];
    const files: string[] = [];

    // Process items in batches to avoid memory issues
    const batchSize = 100;
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);

      // Process batch asynchronously
      const batchPromises = batch.map(async ([item, fileType]) => {
        const itemPath = path.join(currentPath, item);
        const isExcluded = shouldExclude(item, itemPath, rootPath);

        if (fileType === vscode.FileType.Directory) {
          return { item, type: 'folder' as const, isExcluded };
        } else {
          return { item, type: 'file' as const, isExcluded };
        }
      });

      const batchResults = await Promise.all(batchPromises);

      for (const result of batchResults) {
        if (result) {
          if (result.type === 'folder') {
            folders.push(result.item);
          } else {
            files.push(result.item);
          }
        }
      }

      // Update progress for large directories
      if (progressCallback && items.length > batchSize) {
        const progress = Math.min(100, Math.round(((i + batchSize) / items.length) * 100));
        progressCallback(`Processing items: ${progress}%`);
      }

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Sort alphabetically
    folders.sort();
    files.sort();

    // Process folders with memory management
    for (let i = 0; i < folders.length; i++) {
      const folder = folders[i];
      const isLast = i === folders.length - 1 && files.length === 0;
      const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
      const newPrefix = prefix + (isLast ? '    ' : 'â”‚   ');

      // Check if folder is excluded
      const folderPath = path.join(currentPath, folder);
      const isExcluded = shouldExclude(folder, folderPath, rootPath);
      const exclusionIndicator = isExcluded ? ' ğŸš« (auto-hidden)' : '';

      lines.push(`${prefix}${connector}${showIcons ? 'ğŸ“ ' : ''}${folder}/${exclusionIndicator}`);

      if (!isExcluded) {
        const folderPath = path.join(currentPath, folder);
        await generateTreeLines(
          folderPath,
          newPrefix,
          lines,
          depth + 1,
          maxDepth,
          showIcons,
          rootPath,
          progressCallback
        );
      }

      // Yield control periodically to prevent blocking
      if (i % 10 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Process files with memory management
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const isLast = i === files.length - 1;
      const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';

      // Check if file is excluded
      const filePath = path.join(currentPath, file);
      const isExcluded = shouldExclude(file, filePath, rootPath);
      const exclusionIndicator = isExcluded ? ' ğŸš« (auto-hidden)' : '';

      // Get file icon based on extension
      const icon = showIcons ? getFileIcon(file) + ' ' : '';
      lines.push(`${prefix}${connector}${icon}${file}${exclusionIndicator}`);

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  } catch (error) {
    lines.push(`${prefix}â””â”€â”€ âŒ Error reading directory: ${error}`);
  }
}

function getFileIcon(filename: string): string {
  const ext = path.extname(filename).toLowerCase();
  const basename = path.basename(filename).toLowerCase();

  const iconMap: { [key: string]: string } = {
    // JavaScript/TypeScript Ecosystem
    '.js': 'ğŸ“„',
    '.ts': 'ğŸ“„',
    '.jsx': 'ğŸ“„',
    '.tsx': 'ğŸ“„',
    '.json': 'ğŸ“„',
    '.mjs': 'ğŸ“„',
    '.cjs': 'ğŸ“„',

    // Web Technologies
    '.html': 'ğŸŒ',
    '.htm': 'ğŸŒ',
    '.css': 'ğŸ¨',
    '.scss': 'ğŸ¨',
    '.sass': 'ğŸ¨',
    '.less': 'ğŸ¨',
    '.styl': 'ğŸ¨',
    '.vue': 'ğŸŸ¢',
    '.svelte': 'ğŸŸ ',

    // Python Ecosystem
    '.py': 'ğŸ',
    '.pyw': 'ğŸ',
    '.pyi': 'ğŸ',
    '.ipynb': 'ğŸ““',

    // Java Ecosystem
    '.java': 'â˜•',
    '.class': 'â˜•',
    '.jar': 'â˜•',
    '.war': 'â˜•',

    // C/C++ Ecosystem
    '.cpp': 'âš™ï¸',
    '.cc': 'âš™ï¸',
    '.cxx': 'âš™ï¸',
    '.c': 'âš™ï¸',
    '.h': 'âš™ï¸',
    '.hpp': 'âš™ï¸',
    '.hxx': 'âš™ï¸',
    '.obj': 'âš™ï¸',
    '.o': 'âš™ï¸',
    '.so': 'âš™ï¸',
    '.dll': 'âš™ï¸',
    '.exe': 'âš™ï¸',

    // Go
    '.go': 'ğŸ¹',
    '.mod': 'ğŸ¹',
    '.sum': 'ğŸ¹',

    // Rust
    '.rs': 'ğŸ¦€',

    // PHP
    '.php': 'ğŸ˜',
    '.phtml': 'ğŸ˜',

    // Ruby
    '.rb': 'ğŸ’',
    '.erb': 'ğŸ’',
    '.rake': 'ğŸ’',
    '.gemspec': 'ğŸ’',

    // Swift
    '.swift': 'ğŸ',

    // Kotlin
    '.kt': 'ğŸŸ¦',
    '.kts': 'ğŸŸ¦',

    // Scala
    '.scala': 'ğŸ”´',
    '.sc': 'ğŸ”´',

    // C#
    '.cs': 'ğŸŸ£',
    '.csproj': 'ğŸŸ£',
    '.sln': 'ğŸŸ£',

    // F#
    '.fs': 'ğŸŸ£',
    '.fsx': 'ğŸŸ£',
    '.fsproj': 'ğŸŸ£',

    // Dart
    '.dart': 'ğŸ”µ',

    // R
    '.r': 'ğŸ“Š',
    '.R': 'ğŸ“Š',
    '.Rmd': 'ğŸ“Š',

    // MATLAB
    '.m': 'ğŸ“Š',
    '.mat': 'ğŸ“Š',

    // Julia
    '.jl': 'ğŸŸ£',

    // Perl
    '.pl': 'ğŸª',
    '.pm': 'ğŸª',
    '.t': 'ğŸª',

    // Lua
    '.lua': 'ğŸ”µ',

    // Haskell
    '.hs': 'ğŸŸ£',
    '.lhs': 'ğŸŸ£',

    // Clojure
    '.clj': 'ğŸŸ¢',
    '.cljs': 'ğŸŸ¢',
    '.edn': 'ğŸŸ¢',

    // Elixir
    '.ex': 'ğŸŸ£',
    '.exs': 'ğŸŸ£',
    '.eex': 'ğŸŸ£',

    // Erlang
    '.erl': 'ğŸ”´',

    // OCaml
    '.ml': 'ğŸŸ ',
    '.mli': 'ğŸŸ ',

    // Nim
    '.nim': 'ğŸŸ¡',

    // Zig
    '.zig': 'ğŸŸ¡',

    // V
    '.v': 'ğŸ”µ',

    // Assembly
    '.asm': 'âš™ï¸',
    '.s': 'âš™ï¸',
    '.S': 'âš™ï¸',

    // Shell Scripts
    '.sh': 'ğŸš',
    '.bash': 'ğŸš',
    '.zsh': 'ğŸš',
    '.fish': 'ğŸš',
    '.bat': 'ğŸš',
    '.cmd': 'ğŸš',
    '.ps1': 'ğŸš',

    // Configuration Files
    '.yml': 'âš™ï¸',
    '.yaml': 'âš™ï¸',
    '.xml': 'ğŸ“„',
    '.toml': 'âš™ï¸',
    '.ini': 'âš™ï¸',
    '.cfg': 'âš™ï¸',
    '.conf': 'âš™ï¸',

    // Documentation
    '.md': 'ğŸ“',
    '.mdx': 'ğŸ“',
    '.rst': 'ğŸ“',
    '.txt': 'ğŸ“„',
    '.adoc': 'ğŸ“',

    // Images
    '.svg': 'ğŸ–¼ï¸',
    '.png': 'ğŸ–¼ï¸',
    '.jpg': 'ğŸ–¼ï¸',
    '.jpeg': 'ğŸ–¼ï¸',
    '.gif': 'ğŸ–¼ï¸',
    '.ico': 'ğŸ–¼ï¸',
    '.bmp': 'ğŸ–¼ï¸',
    '.tiff': 'ğŸ–¼ï¸',
    '.webp': 'ğŸ–¼ï¸',

    // Documents
    '.pdf': 'ğŸ“•',
    '.doc': 'ğŸ“„',
    '.docx': 'ğŸ“„',
    '.xls': 'ğŸ“Š',
    '.xlsx': 'ğŸ“Š',
    '.ppt': 'ğŸ“Š',
    '.pptx': 'ğŸ“Š',

    // Archives
    '.zip': 'ğŸ“¦',
    '.tar': 'ğŸ“¦',
    '.gz': 'ğŸ“¦',
    '.bz2': 'ğŸ“¦',
    '.rar': 'ğŸ“¦',
    '.7z': 'ğŸ“¦',

    // Database
    '.sql': 'ğŸ—„ï¸',
    '.db': 'ğŸ—„ï¸',
    '.sqlite': 'ğŸ—„ï¸',

    // GraphQL
    '.graphql': 'ğŸŸ£',
    '.gql': 'ğŸŸ£',

    // Docker
    dockerfile: 'ğŸ³',

    // Makefiles
    makefile: 'âš™ï¸',

    // Special Files
    '.gitignore': 'ğŸš«',
    '.env': 'ğŸ”’',
    '.lock': 'ğŸ”’',
    '.log': 'ğŸ“‹',
    '.tmp': 'ğŸ—‘ï¸',
    '.cache': 'ğŸ—‘ï¸',
    '.bak': 'ğŸ—‘ï¸',
    '.old': 'ğŸ—‘ï¸',
  };

  // Check for special filenames (case-insensitive)
  if (basename === 'dockerfile') return 'ğŸ³';
  if (basename === 'makefile') return 'âš™ï¸';
  if (basename === 'readme' || basename.startsWith('readme.')) return 'ğŸ“–';
  if (basename === 'license' || basename.startsWith('license.')) return 'ğŸ“œ';
  if (basename === 'changelog' || basename.startsWith('changelog.')) return 'ğŸ“';
  if (basename === '.gitignore') return 'ğŸš«';
  if (basename === '.env') return 'ğŸ”’';

  return iconMap[ext] || 'ğŸ“„';
}

export async function readGitignore(rootPath: string): Promise<string[]> {
  const gitignorePath = path.join(rootPath, '.gitignore');
  try {
    const content = await vscode.workspace.fs.readFile(vscode.Uri.file(gitignorePath));
    return content
      .toString()
      .split('\n')
      .filter(line => line.trim() && !line.startsWith('#'))
      .map(line => line.trim());
  } catch {
    return [];
  }
}

/**
 * Converts a glob pattern to a RegExp for file path matching.
 *
 * Supports common glob patterns:
 * - '*' matches any characters except path separators (e.g., "*.js" matches "file.js")
 * - '**' matches any path segments including separators (e.g., double-star patterns)
 * - '?' matches any single character
 *
 * @param pattern - The glob pattern to convert (e.g., "*.log", "temp?")
 * @returns A RegExp object that can be used to test file paths
 *
 * @example
 * ```typescript
 * const regex = globToRegex("*.log");
 * regex.test("error.log"); // true
 * regex.test("app.js"); // false
 * ```
 */
function globToRegex(pattern: string): RegExp {
  // Handle directory patterns ending with /
  if (pattern.endsWith('/')) {
    // Remove trailing slash and treat as exact directory name match
    const dirName = pattern.slice(0, -1);
    const escapedDirName = dirName.replace(/[.+^${}()|[\]\\]/g, '\\$&');
    return new RegExp(`(^|/)${escapedDirName}(/|$)`, 'i');
  }

  // Escape special regex characters except for our glob patterns
  let regexPattern = pattern
    .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
    .replace(/\\\*/g, '__STAR__') // Temporarily replace escaped asterisks
    .replace(/\*\*/g, '.*') // ** means match any path segment(s)
    .replace(/__STAR__/g, '[^/]*') // * means match any characters except path separator
    .replace(/\\\?/g, '.'); // ? means match any single character

  // For exact directory/file matches, anchor the pattern
  if (!pattern.includes('*') && !pattern.includes('/')) {
    // Exact name match - should only match at path boundaries
    regexPattern = `(^|/)${regexPattern}(/|$)`;
  } else if (pattern.includes('**/')) {
    // Double star patterns - ensure proper path matching
    regexPattern = `(^|/)${regexPattern}(/|$)`;
  } else if (pattern.startsWith('*.')) {
    // File extension patterns - anchor to end of string
    regexPattern = `${regexPattern}$`;
  }

  return new RegExp(regexPattern, 'i');
}

export function shouldExclude(item: string, fullPath?: string, rootPath?: string): boolean {
  // Get user-defined exclusions from settings
  const config = vscode.workspace.getConfiguration('filetree-pro');
  const userExclusions = config.get<string[]>('exclude', []);
  const respectGitignore = config.get<boolean>('respectGitignore', true);

  // Read .gitignore patterns if enabled (synchronously for now)
  let gitignorePatterns: string[] = [];
  if (respectGitignore && rootPath) {
    try {
      const gitignorePath = path.join(rootPath, '.gitignore');
      if (fs.existsSync(gitignorePath)) {
        const content = fs.readFileSync(gitignorePath, 'utf8');
        gitignorePatterns = content
          .split('\n')
          .filter((line: string) => line.trim() && !line.startsWith('#'))
          .map((line: string) => line.trim());
      }
    } catch (error) {
      // Ignore errors and continue without gitignore
    }
  }

  // Common folders and files to exclude
  const defaultExcludePatterns = [
    // Build and dependency folders
    'node_modules',
    'dist',
    'build',
    'out',
    'target',
    'bin',
    'obj',
    '.next',
    '.nuxt',
    '.output',
    'coverage',
    'coverage.lcov',
    '.nyc_output',
    'bower_components',
    'jspm_packages',

    // Version control
    '.git',
    '.svn',
    '.hg',
    '.bzr',

    // IDE and editor folders
    '.vscode',
    '.idea',
    '.vs',
    '.cursor',
    '.atom',
    '.sublime-project',
    '.sublime-workspace',

    // Environment files (sensitive)
    '.env.local',
    '.env.production',
    '.env.development',
    '.env.test',
    'venv',
    '.venv',
    'env',
    '.python-version',
    '.ruby-version',
    '.node-version',

    // OS generated
    '.DS_Store',
    'Thumbs.db',
    '.Trash',
    'desktop.ini',
    '$RECYCLE.BIN',

    // Logs and temp files
    '*.log',
    '*.tmp',
    '*.cache',
    '*.pyc',
    '__pycache__',
    '*.swp',
    '*.swo',
    '*~',

    // Package manager lock files (often needed for debugging/reproducible builds)
    // Note: These are sometimes committed and needed, so being more selective
    'composer.lock',
    'Gemfile.lock',
    'Pipfile.lock',
    'mix.lock',

    // Build artifacts
    '*.min.js',
    '*.min.css',
    '*.map',
    '*.bundle.js',
    '*.chunk.js',

    // Generated/config files (commonly auto-generated but sometimes important)
    '.eslintcache',
    '.babelrc',
    '.babelrc.js',
    'tsconfig.build.json',
    'karma.conf.js',
  ];

  // Combine default, user, and gitignore exclusions
  const excludePatterns = [...defaultExcludePatterns, ...userExclusions, ...gitignorePatterns];

  const itemLower = item.toLowerCase();

  // For user patterns with glob syntax (like **/node_modules/**), we need the full path
  const pathToCheck = fullPath || item;

  // Normalize path separators for cross-platform compatibility
  const normalizedPath = pathToCheck.replace(/\\/g, '/');

  // Check exact matches (case-insensitive) - for simple patterns
  if (
    excludePatterns.some(pattern => {
      // Skip glob patterns for exact match check
      if (pattern.includes('*') || pattern.includes('/')) {
        return false;
      }
      // For exact name matching, only match complete names, not substrings
      return pattern.toLowerCase() === itemLower;
    })
  ) {
    return true;
  }

  // Check wildcard and glob patterns
  for (const pattern of excludePatterns) {
    if (pattern.includes('*') || pattern.includes('/')) {
      try {
        // Handle file extension patterns like *.log, *.tmp first (simple case)
        if (pattern.startsWith('*.') && !pattern.includes('/')) {
          const extension = pattern.substring(1); // Remove the * to get .log, .tmp, etc.
          if (item.toLowerCase().endsWith(extension.toLowerCase())) {
            return true;
          }
        } else {
          // Handle complex glob patterns like **/node_modules/**, **/*.log, etc.
          const regex = globToRegex(pattern);
          if (regex.test(normalizedPath) || regex.test(item)) {
            return true;
          }
        }
      } catch (error) {
        // If there's an error with the pattern, log it and continue
        console.warn(`Invalid exclusion pattern: ${pattern}`, error);
        continue;
      }
    }
  }

  // Check for common build/artifact patterns (only exact matches)
  if (
    itemLower === 'build' ||
    itemLower === 'dist' ||
    itemLower === 'cache' ||
    itemLower === 'temp' ||
    itemLower === 'tmp'
  ) {
    return true;
  }

  return false;
}

export async function generateMarkdownTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const lines: string[] = [];

  // Add header
  lines.push(`# File Tree: ${path.basename(rootPath)}`);
  lines.push('');
  lines.push(`Generated on: ${new Date().toLocaleString()}`);
  lines.push(`Root path: \`${rootPath}\``);
  lines.push('');
  lines.push('```');

  // Generate tree structure
  await generateTreeLines(rootPath, '', lines, 0, maxDepth, showIcons, rootPath, progressCallback);

  lines.push('```');
  lines.push('');
  lines.push('---');
  lines.push('*Generated by FileTree Pro Extension*');

  return lines.join('\n');
}

export async function generateJsonTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const treeData = await buildTreeData(
    rootPath,
    maxDepth,
    showIcons,
    rootPath,
    0,
    progressCallback
  );

  const jsonOutput = {
    name: path.basename(rootPath),
    path: rootPath,
    type: 'directory',
    children: treeData,
    generated: new Date().toISOString(),
    generator: 'FileTree Pro Extension',
    note: 'Common build folders, dependencies, and temporary files are automatically excluded.',
    showIcons: showIcons,
  };

  return JSON.stringify(jsonOutput, null, 2);
}

export async function generateSvgTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const treeData = await buildTreeData(
    rootPath,
    maxDepth,
    showIcons,
    rootPath,
    0,
    progressCallback
  );

  // Calculate dimensions based on content
  const nodeCount = countNodes(treeData);
  const svgWidth = 1000;
  const svgHeight = Math.max(800, nodeCount * 25 + 100);

  let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">
  <defs>
      <style>
      .title { font-family: 'Arial', sans-serif; font-size: 18px; font-weight: bold; fill: #2c3e50; }
      .subtitle { font-family: 'Arial', sans-serif; font-size: 12px; fill: #7f8c8d; }
      .folder-text { font-family: 'Consolas', 'Courier New', monospace; font-size: 14px; fill: #27ae60; font-weight: bold; }
      .file-text { font-family: 'Consolas', 'Courier New', monospace; font-size: 14px; fill: #3498db; }
      .icon { font-family: 'Arial', sans-serif; font-size: 16px; }
      .line { stroke: #bdc3c7; stroke-width: 1.5; }
      .background { fill: #f8f9fa; }
      .header-bg { fill: #ecf0f1; }
      </style>
  </defs>

  <!-- Background -->
  <rect width="${svgWidth}" height="${svgHeight}" class="background"/>

  <!-- Header -->
  <rect x="0" y="0" width="${svgWidth}" height="60" class="header-bg"/>
  <text x="20" y="25" class="title">ğŸ“ File Tree: ${path.basename(rootPath)}</text>
          <text x="20" y="45" class="subtitle">Generated: ${new Date().toLocaleString()} | FileTree Pro Extension</text>

  <!-- Tree Structure -->`;

  let yOffset = 80;
  const renderNode = (node: any, x: number, level: number, isLast: boolean = false) => {
    const icon = showIcons ? (node.type === 'directory' ? 'ğŸ“' : getFileIcon(node.name)) : '';
    const displayName = node.name + (node.type === 'directory' ? '/' : '');
    const textClass = node.type === 'directory' ? 'folder-text' : 'file-text';

    // Draw connecting line if not root
    if (level > 0) {
      svgContent += `
    <line x1="${x - 15}" y1="${yOffset - 10}" x2="${x - 15}" y2="${yOffset}" class="line"/>`;
    }

    // Draw horizontal line
    svgContent += `
    <line x1="${x - 15}" y1="${yOffset}" x2="${x - 5}" y2="${yOffset}" class="line"/>`;

    // Draw icon and text
    if (showIcons && icon) {
      svgContent += `
    <text x="${x}" y="${yOffset + 5}" class="icon">${icon}</text>
    <text x="${x + 25}" y="${yOffset + 5}" class="${textClass}">${displayName}</text>`;
    } else {
      svgContent += `
    <text x="${x}" y="${yOffset + 5}" class="${textClass}">${displayName}</text>`;
    }

    if (node.children && node.children.length > 0) {
      yOffset += 30;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const isLastChild = i === node.children.length - 1;
        renderNode(child, x + 30, level + 1, isLastChild);
        yOffset += 25;
      }
    }
    yOffset += 10;
  };

  for (const node of treeData) {
    renderNode(node, 30, 0);
  }

  svgContent += `
</svg>`;

  return svgContent;
}

export async function generateAsciiTree(
  rootPath: string,
  maxDepth: number,
  showIcons: boolean,
  progressCallback?: (message: string) => void
): Promise<string> {
  const lines: string[] = [];

  // Add header
  lines.push(`File Tree: ${path.basename(rootPath)}`);
  lines.push(`Generated on: ${new Date().toLocaleString()}`);
  lines.push(`Root path: ${rootPath}`);
  lines.push('');
  lines.push('â”€'.repeat(80));

  // Generate tree structure
  await generateTreeLines(rootPath, '', lines, 0, maxDepth, showIcons, rootPath, progressCallback);

  lines.push('');
  lines.push('â”€'.repeat(80));
  lines.push('Generated by FileTree Pro Extension');

  return lines.join('\n');
}

function countNodes(nodes: any[]): number {
  let count = nodes.length;
  for (const node of nodes) {
    if (node.children && node.children.length > 0) {
      count += countNodes(node.children);
    }
  }
  return count;
}

export async function buildTreeData(
  currentPath: string,
  maxDepth: number,
  showIcons: boolean,
  rootPath: string,
  depth: number = 0,
  progressCallback?: (message: string) => void
): Promise<any[]> {
  if (depth > maxDepth) {
    return [];
  }

  try {
    // Update progress for large directories
    if (progressCallback && depth === 0) {
      progressCallback(`Building tree data: ${path.basename(currentPath)}`);
    }

    const items = await vscode.workspace.fs.readDirectory(vscode.Uri.file(currentPath));
    const result: any[] = [];

    // Sort items: folders first, then files
    const folders: string[] = [];
    const files: string[] = [];

    // Process items in batches to avoid memory issues
    const batchSize = 100;
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);

      // Process batch asynchronously
      const batchPromises = batch.map(async ([item, fileType]) => {
        const itemPath = path.join(currentPath, item);
        const isExcluded = shouldExclude(item, itemPath, rootPath);

        if (fileType === vscode.FileType.Directory) {
          return { item, type: 'folder' as const, isExcluded };
        } else {
          return { item, type: 'file' as const, isExcluded };
        }
      });

      const batchResults = await Promise.all(batchPromises);

      for (const batchResult of batchResults) {
        if (batchResult && !batchResult.isExcluded) {
          if (batchResult.type === 'folder') {
            folders.push(batchResult.item);
          } else {
            files.push(batchResult.item);
          }
        }
      }

      // Update progress for large directories
      if (progressCallback && items.length > batchSize) {
        const progress = Math.min(100, Math.round(((i + batchSize) / items.length) * 100));
        progressCallback(`Processing items: ${progress}%`);
      }

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Sort alphabetically
    folders.sort();
    files.sort();

    // Process folders with memory management
    for (let i = 0; i < folders.length; i++) {
      const folder = folders[i];
      const folderPath = path.join(currentPath, folder);
      const children = await buildTreeData(
        folderPath,
        maxDepth,
        showIcons,
        rootPath,
        depth + 1,
        progressCallback
      );

      result.push({
        name: folder,
        type: 'directory',
        path: folderPath,
        children: children,
        icon: showIcons ? 'ğŸ“' : null,
      });

      // Yield control periodically to prevent blocking
      if (i % 10 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Process files with memory management
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      result.push({
        name: file,
        type: 'file',
        path: path.join(currentPath, file),
        icon: showIcons ? getFileIcon(file) : null,
      });

      // Yield control periodically to prevent blocking
      if (i % 50 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    return result;
  } catch (error) {
    return [
      {
        name: 'Error reading directory',
        type: 'error',
        error: String(error),
      },
    ];
  }
}
